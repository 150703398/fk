<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Cartoon Tetris Pro</title>

<style>
:root {
  --bg: #7fd3ff;
  --panel: #ffffff;
  --outline: #333;
  --shadow: rgba(0,0,0,.25);
  --text: #222;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  background: linear-gradient(#8ee7ff, #5fc8ff);
  font-family: "Comic Sans MS", "Arial Rounded MT Bold", sans-serif;
  display: flex;
  justify-content: center;
}

#app {
  width: 100%;
  max-width: 420px;
  padding: 8px;
}

.panel {
  background: var(--panel);
  border-radius: 16px;
  box-shadow: 0 6px 0 var(--shadow);
  padding: 8px;
  margin-bottom: 8px;
}

#top {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

button {
  border: none;
  background: #ffce55;
  border-radius: 12px;
  padding: 6px 14px;
  font-size: 16px;
  box-shadow: 0 4px 0 #d9a441;
}

canvas {
  width: 100%;
  aspect-ratio: 10 / 20;
  background: #eaf9ff;
  border-radius: 12px;
  box-shadow: inset 0 0 0 4px #333;
  touch-action: none;
}

#bottom {
  font-size: 14px;
  text-align: center;
  color: var(--text);
  line-height: 1.6;
}
</style>
</head>

<body>
<div id="app">

  <div id="top" class="panel">
    <div>ğŸ¯ åˆ†æ•°ï¼š<span id="score">0</span></div>
    <button id="start">å¼€å§‹</button>
  </div>

  <div class="panel">
    <canvas id="game" width="300" height="600"></canvas>
  </div>

  <div class="panel" id="bottom">
    æ“ä½œè¯´æ˜ï¼š<br>
    å‘ä¸Šï¼šæ—‹è½¬ ï½œ å‘å·¦ï¼šå·¦ç§» ï½œ å‘å³ï¼šå³ç§» ï½œ å‘ä¸‹ï¼šä¸‹ç§»
  </div>

</div>

<script>
/* ================== åŸºç¡€å‚æ•° ================== */
const COLS = 10, ROWS = 20, BLOCK = 30;
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const scoreEl = document.getElementById("score");
const startBtn = document.getElementById("start");

const LEADERBOARD_API = "https://fktop.wuyuping7262.workers.dev/";

/* ================== é¢œè‰² ================== */
const COLORS = [
  null,
  "#ff595e", "#ffca3a", "#8ac926",
  "#1982c4", "#6a4c93", "#ff924c", "#43aa8b"
];

/* ================== æ–¹å—å®šä¹‰ï¼ˆSRSï¼‰ ================== */
const SHAPES = {
  I: [
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]
  ],
  O: [
    [[1,1],[1,1]]
  ],
  T: [
    [[0,1,0],[1,1,1],[0,0,0]],
    [[0,1,0],[0,1,1],[0,1,0]],
    [[0,0,0],[1,1,1],[0,1,0]],
    [[0,1,0],[1,1,0],[0,1,0]]
  ],
  L: [
    [[0,0,1],[1,1,1],[0,0,0]],
    [[0,1,0],[0,1,0],[0,1,1]],
    [[0,0,0],[1,1,1],[1,0,0]],
    [[1,1,0],[0,1,0],[0,1,0]]
  ],
  J: [
    [[1,0,0],[1,1,1],[0,0,0]],
    [[0,1,1],[0,1,0],[0,1,0]],
    [[0,0,0],[1,1,1],[0,0,1]],
    [[0,1,0],[0,1,0],[1,1,0]]
  ],
  S: [
    [[0,1,1],[1,1,0],[0,0,0]],
    [[0,1,0],[0,1,1],[0,0,1]]
  ],
  Z: [
    [[1,1,0],[0,1,1],[0,0,0]],
    [[0,0,1],[0,1,1],[0,1,0]]
  ]
};

const TYPES = Object.keys(SHAPES);

/* ================== æ¸¸æˆçŠ¶æ€ ================== */
let board, piece, dropTimer, lastTime = 0;
let score = 0;
let running = false;

/* ================== å·¥å…·å‡½æ•° ================== */
function newBoard() {
  return Array.from({length: ROWS}, () => Array(COLS).fill(0));
}

function randomPiece() {
  const type = TYPES[Math.floor(Math.random() * TYPES.length)];
  return {
    type,
    shape: SHAPES[type],
    rot: 0,
    x: Math.floor(COLS / 2) - 1,
    y: 0,
    color: TYPES.indexOf(type) + 1
  };
}

function collide(px, py, rot) {
  const m = piece.shape[rot];
  for (let y = 0; y < m.length; y++) {
    for (let x = 0; x < m[y].length; x++) {
      if (m[y][x]) {
        const nx = px + x;
        const ny = py + y;
        if (nx < 0 || nx >= COLS || ny >= ROWS || board[ny]?.[nx]) {
          return true;
        }
      }
    }
  }
  return false;
}

/* ================== ç»˜åˆ¶ ================== */
function drawBlock(x, y, c) {
  ctx.fillStyle = COLORS[c];
  ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 2;
  ctx.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
  ctx.shadowColor = "rgba(0,0,0,.25)";
  ctx.shadowBlur = 6;
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  board.forEach((r,y)=>r.forEach((c,x)=>c && drawBlock(x,y,c)));
  const m = piece.shape[piece.rot];
  m.forEach((r,y)=>r.forEach((v,x)=>v && drawBlock(piece.x+x,piece.y+y,piece.color)));
}

/* ================== æ›´æ–° ================== */
function merge() {
  const m = piece.shape[piece.rot];
  m.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) board[piece.y+y][piece.x+x] = piece.color;
  }));
}

function clearLines() {
  let cleared = 0;
  board = board.filter(r => r.some(c => !c) || (cleared++, false));
  while (board.length < ROWS) board.unshift(Array(COLS).fill(0));
  score += cleared * cleared * 100;
  scoreEl.textContent = score;
}

function drop() {
  if (!collide(piece.x, piece.y+1, piece.rot)) {
    piece.y++;
  } else {
    merge();
    clearLines();
    piece = randomPiece();
    if (collide(piece.x, piece.y, piece.rot)) running = false;
  }
}

function update(time=0) {
  if (!running) return;
  if (time - lastTime > 500) {
    drop();
    lastTime = time;
  }
  draw();
  requestAnimationFrame(update);
}

/* ================== æ§åˆ¶ ================== */
document.addEventListener("keydown", e => {
  if (!running) return;
  if (e.key === "ArrowLeft" && !collide(piece.x-1,piece.y,piece.rot)) piece.x--;
  if (e.key === "ArrowRight" && !collide(piece.x+1,piece.y,piece.rot)) piece.x++;
  if (e.key === "ArrowDown") drop();
  if (e.key === "ArrowUp") {
    const r = (piece.rot+1)%piece.shape.length;
    if (!collide(piece.x,piece.y,r)) piece.rot = r;
  }
});

/* ================== è§¦å± ================== */
let sx, sy;
canvas.addEventListener("touchstart", e=>{
  const t=e.touches[0]; sx=t.clientX; sy=t.clientY;
});
canvas.addEventListener("touchend", e=>{
  const t=e.changedTouches[0];
  const dx=t.clientX-sx, dy=t.clientY-sy;
  if (Math.abs(dx)>Math.abs(dy)) {
    if (dx>30 && !collide(piece.x+1,piece.y,piece.rot)) piece.x++;
    if (dx<-30 && !collide(piece.x-1,piece.y,piece.rot)) piece.x--;
  } else {
    if (dy>30) drop();
    if (dy<-30) {
      const r=(piece.rot+1)%piece.shape.length;
      if(!collide(piece.x,piece.y,r)) piece.rot=r;
    }
  }
});

/* ================== å¯åŠ¨ ================== */
startBtn.onclick = ()=>{
  board = newBoard();
  piece = randomPiece();
  score = 0;
  scoreEl.textContent = 0;
  running = true;
  lastTime = 0;
  update();
};
</script>
</body>
</html>
