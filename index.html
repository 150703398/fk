<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
<title>Cartoon Tetris Pro</title>

<style>
html,body{
  margin:0;
  background:#7dd3fc;
  font-family:"Comic Sans MS","Segoe UI",sans-serif;
  overflow:hidden;
}

#gameWrap{
  display:flex;
  justify-content:center;
  align-items:flex-start;
  gap:14px;
  padding:10px;
}

canvas{
  background:#e0f2fe;
  border-radius:14px;
  box-shadow:0 10px 0 #38bdf8,0 20px 40px rgba(0,0,0,.3);
  touch-action:none;
}

#side{
  display:flex;
  flex-direction:column;
  gap:10px;
}

.panel{
  background:#fff;
  border-radius:14px;
  padding:10px;
  box-shadow:0 6px 0 #94a3b8;
  text-align:center;
}

#help{
  position:absolute;
  bottom:8px;
  width:100%;
  text-align:center;
  font-size:14px;
  color:#0f172a;
  font-weight:bold;
  pointer-events:none;
}
</style>
</head>

<body>

<div id="gameWrap">
  <canvas id="game" width="300" height="600"></canvas>

  <div id="side">
    <div class="panel">
      <div>ä¸‹ä¸€ä¸ª</div>
      <canvas id="next" width="120" height="120"></canvas>
    </div>
    <div class="panel">
      <div>åˆ†æ•°</div>
      <div id="score">0</div>
      <div>éš¾åº¦</div>
      <div id="level">1</div>
    </div>
    <div class="panel">
      <div>ğŸ† Top10</div>
      <ol id="rank"></ol>
    </div>
  </div>
</div>

<div id="help">
æ“ä½œè¯´æ˜ï¼šå‘ä¸Šï¼šæ—‹è½¬ï¼Œå‘å·¦ï¼šå·¦ç§»ï¼Œå‘å³ï¼šå³ç§»ï¼Œå‘ä¸‹ï¼šä¸‹ç§»
</div>

<script>
/* ================== åŸºç¡€é…ç½® ================== */
const COLS=10, ROWS=20, SIZE=30;
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const nextC=document.getElementById("next").getContext("2d");

let board=[...Array(ROWS)].map(()=>Array(COLS).fill(0));
let score=0,level=1,combo=0;
let dropInterval=800,lastDrop=0,lockTimer=0;

/* ================== æ–¹å—å®šä¹‰ ================== */
const COLORS=[null,"#f87171","#60a5fa","#34d399","#fbbf24","#c084fc","#fb7185","#38bdf8"];
const SHAPES={
 I:[[1,1,1,1]],
 J:[[1,0,0],[1,1,1]],
 L:[[0,0,1],[1,1,1]],
 O:[[1,1],[1,1]],
 S:[[0,1,1],[1,1,0]],
 T:[[0,1,0],[1,1,1]],
 Z:[[1,1,0],[0,1,1]]
};

/* ================== å½“å‰æ–¹å— ================== */
let cur, next;

/* ================== å·¥å…· ================== */
function rotate(m){
  return m[0].map((_,i)=>m.map(r=>r[i]).reverse());
}
function collide(px,py,shape){
  for(let y=0;y<shape.length;y++)
    for(let x=0;x<shape[y].length;x++)
      if(shape[y][x]&&(board[py+y]?.[px+x]!==0))
        return true;
  return false;
}

/* ================== ç”Ÿæˆ ================== */
function spawn(){
  cur=next||randomPiece();
  cur.x=3;cur.y=0;
  next=randomPiece();
}
function randomPiece(){
  const keys=Object.keys(SHAPES);
  const k=keys[Math.random()*keys.length|0];
  return{shape:SHAPES[k],color:COLORS[keys.indexOf(k)+1],x:0,y:0};
}

/* ================== åˆå¹¶ ================== */
function merge(){
  cur.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v) board[cur.y+y][cur.x+x]=cur.color;
  }));
}

/* ================== æ¸…è¡Œ ================== */
function clearLines(){
  let cleared=0;
  board=board.filter(r=>r.some(c=>!c)||!(cleared++));
  while(board.length<ROWS) board.unshift(Array(COLS).fill(0));
  if(cleared){
    combo++;
    score+=cleared*100*combo;
  }else combo=0;
}

/* ================== ç»˜åˆ¶ ================== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  board.forEach((r,y)=>r.forEach((c,x)=>{
    if(c){
      ctx.fillStyle=c;
      ctx.fillRect(x*SIZE,y*SIZE,SIZE,SIZE);
      ctx.strokeStyle="#0f172a";
      ctx.strokeRect(x*SIZE,y*SIZE,SIZE,SIZE);
    }
  }));
  cur.shape.forEach((r,y)=>r.forEach((v,x)=>{
    if(v){
      ctx.fillStyle=cur.color;
      ctx.fillRect((cur.x+x)*SIZE,(cur.y+y)*SIZE,SIZE,SIZE);
      ctx.strokeRect((cur.x+x)*SIZE,(cur.y+y)*SIZE,SIZE,SIZE);
    }
  }));
}

/* ================== æ›´æ–° ================== */
function update(t=0){
  if(t-lastDrop>dropInterval){
    if(!collide(cur.x,cur.y+1,cur.shape)) cur.y++;
    else{
      lockTimer+=t-lastDrop;
      if(lockTimer>500){
        merge();clearLines();spawn();lockTimer=0;
      }
    }
    lastDrop=t;
  }
  draw();
  requestAnimationFrame(update);
}

/* ================== è¾“å…¥ ================== */
document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft"&&!collide(cur.x-1,cur.y,cur.shape)) cur.x--;
  if(e.key==="ArrowRight"&&!collide(cur.x+1,cur.y,cur.shape)) cur.x++;
  if(e.key==="ArrowDown") cur.y++;
  if(e.key==="ArrowUp"){
    const r=rotate(cur.shape);
    if(!collide(cur.x,cur.y,r)) cur.shape=r;
  }
});

/* ================== è§¦å± ================== */
let sx,sy;
canvas.addEventListener("touchstart",e=>{
  const t=e.touches[0];sx=t.clientX;sy=t.clientY;
});
canvas.addEventListener("touchend",e=>{
  const t=e.changedTouches[0];
  const dx=t.clientX-sx,dy=t.clientY-sy;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>20&&!collide(cur.x+1,cur.y,cur.shape))cur.x++;
    if(dx<-20&&!collide(cur.x-1,cur.y,cur.shape))cur.x--;
  }else{
    if(dy>20)cur.y++;
    if(dy<-20){
      const r=rotate(cur.shape);
      if(!collide(cur.x,cur.y,r)) cur.shape=r;
    }
  }
});

/* ================== æ’è¡Œæ¦œ ================== */
const LEADERBOARD_API="https://fktop.wuyuping7262.workers.dev/";
async function loadRank(){
  try{
    const r=await fetch(LEADERBOARD_API);
    const d=await r.json();
    document.getElementById("rank").innerHTML=d.map(i=>`<li>${i.score}ï¼ˆLv.${i.level}ï¼‰</li>`).join("");
  }catch{}
}

/* ================== å¯åŠ¨ ================== */
spawn();spawn();
update();
loadRank();
</script>

</body>
</html>
